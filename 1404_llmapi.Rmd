# Working with OpenAI's API

This module introduces the basics of interacting with OpenAI's API from R. We'll explore how to make API calls, handle responses, and integrate AI capabilities into data science workflows.

```{r include = FALSE}
source("common.R")

ds4p_funyoutube <- read.csv("admin/csv/ds4p_funyoutube.csv", sep = "")
ds4p_urls <- read.csv("./admin/csv/ds4p_urls.csv")

# install.packages("devtools")

if (!require("tweetrmd"))  devtools::install_github("gadenbuie/tweetrmd")
library(tweetrmd) #... embedding tweets
library(vembedr)  #... embedding youtube videos
library(knitr)
library(tidyverse)
```


## Getting Started

First, we need to load the required packages:

```{r, echo=FALSE, message=FALSE}
library(httr)       # For making API requests 
library(jsonlite)   # For handling JSON responses
library(tidyverse)  # For data wrangling
```

### API Authentication

To use OpenAI's API, you'll need an API key. Like we learned with other APIs, it's important to keep this secure:

```
# Store API key securely (NEVER commit to Git!)
openai_api_key <- readLines("path/to/api_key.txt")
```

```{r, echo=FALSE, include=FALSE}
openai_api_key <- readLines("admin/secrets/openai_api_key.txt")
```

### Making API Requests

The core workflow involves:

- Constructing the API request
- Sending it to OpenAI's endpoint
- Processing the response

Next, we define a function to generate text using OpenAI's API. The function takes a prompt as input and returns the generated text.

Here's a basic function for text generation:


```{r, echo=TRUE}
generate_text <- function(prompt) {
  response <- POST(
  # curl https://api.openai.com/v1/chat/completions 
  url = "https://api.openai.com/v1/chat/completions", 
  # -H "Authorization: Bearer $OPENAI_API_KEY"
  add_headers(Authorization = paste("Bearer", openai_api_key)),
  # -H "Content-Type: application/json"
  content_type_json(),
  # -d '{
  #   "model": "gpt-3.5-turbo",
  #   "messages": [{"role": "user", "content": "What is a banana?"}] 
  # }'
  encode = "json",
  body = list(
    model = "gpt-3.5-turbo",
    messages = list(list(role = "user", content = prompt))
  )
)
  
  str_content <- content(response, "text", encoding = "UTF-8")
  parsed <- fromJSON(str_content)
  
  #return(parsed$choices[[1]]$text)
  return(parsed)
}
```


## Example Usage and Handling the Response

Now that we’ve defined our generate_text() function, let’s test it by sending a request to OpenAI’s API and working with the response.

### Step 1: Send a Request

```{r cache=TRUE}
prompt <- "Summarize the key steps in a data science workflow:"
generated_text <- generate_text(prompt)

```

### Step 2: Examine the Raw API Response


When we call the `generate_text(prompt)` function, OpenAI's API returns a structured response in JSON format, which R reads as a list. This response contains multiple components, but the most important part is the generated text.

Let's print the raw response to see its structure. 
```{r cache=TRUE}

print(generated_text)

```

As you can see, the response is a nested list containing various metadata (e.g., request ID, model name, creation time), the AI-generated response (inside `$choices[[1]]$message$content`), token usage information (inside $usage$total_tokens), and more.

### Step 3: Extract the AI-Generated Text

Since the response contains both metadata and content, we need to extract only the generated text. The key part of the response is stored in:

```{r cache=TRUE}

ai_response <- generated_text$choices$message$content

```

Now, let's print the AI-generated text:

```{r cache=TRUE}
print(ai_response)
```

Ok, so that wasn't really readable. Let's try to format it a bit better:


```{r cache=TRUE, results='asis'}

cat(ai_response)

```

### Step 4: Understanding Token Usage

Since OpenAI charges based on token usage, it's useful to monitor how many tokens are used per request. The API response includes:

- usage$prompt_tokens → Tokens in the input prompt
- usage$completion_tokens → Tokens generated by the model
- usage$total_tokens → The total token count for billing

To check token usage:

```{r cache=TRUE}
print(generated_text$usage$total_tokens)  # Total tokens used
print(generated_text$usage$completion_tokens)  # Tokens used for output
print(generated_text$usage$prompt_tokens)  # Tokens used for input
```


## Error Handling

Like we've seen with other APIs, it's important to handle errors gracefully. As with any API call, errors can occur due to network issues, invalid requests, or rate limits. To ensure our script doesn’t crash, we can wrap API calls in `tryCatch()`:

```{r echo=TRUE}
generate_text_safe <- function(prompt) {
  tryCatch({
    generate_text(prompt)
  }, error = function(e) {
    warning("API call failed: ", e$message)
    return(NULL)
  })
}
```

Now, we can use `generate_text_safe()` to handle errors. If an error occurs, the function will return `NULL` and print a warning message.

## Processing Multiple Requests

When working with multiple prompts, we can use `purrr::map_chr()` to process them efficiently:


```{r cache=TRUE}
library(purrr)
prompts <- c(
  "Define p-value",
  "Explain Type I error",
  "What is statistical power?"
)
responses <- list()
responses <- map(prompts, generate_text_safe)

```

This code generates text for each prompt in the `prompts` vector. If an error occurs, the response will be `NULL`. After running this code, we can examine the responses and handle any errors. I've included a table below to display the responses.

```{r message = FALSE, warning = FALSE, echo = FALSE, cache=TRUE}
# can we make this table with the prompt and the response?
responses_df <- tibble(prompt = prompts, 
                         ai_response = map_chr(responses, ~ .x$choices$message$content),
                         tokens_used = map_dbl(responses, ~ .x$usage$total_tokens),
                         model = map_chr(responses, ~ .x$model),
                         completion_time = map_dbl(responses, ~ .x$created))

responses_df <- responses_df %>%
  mutate(completion_time = as.POSIXct(completion_time, tz = "UTC"))

responses_df %>%
  DT::datatable(
    rownames = FALSE,
    class = "cell-border stripe",
    # filter = list(position = 'top'),
    options = list(
      pageLength = nrow(responses_df),
      autoWidth = TRUE,
      bInfo = FALSE,
      paging = FALSE
    )
  )
```
As you can see, the table displays the prompts, AI-generated responses, token usage, model name, and completion time for each request. This information can help us monitor the API usage and response quality.


### Rate Limiting

OpenAI has rate limits we need to respect. We can add delays between requests to avoid exceeding these limits. Here's a throttled version of the `generate_text()` function:

```{r}
generate_text_throttled <- function(prompt) {
  Sys.sleep(1) # Wait 1 second between requests
  generate_text_safe(prompt)
}
```

This function adds a 1-second delay between requests to avoid exceeding OpenAI's rate limits. You can adjust the delay as needed based on the API's rate limits.

## Conclusion

In this guide, we've covered how to generate text using OpenAI's GPT-3 API in R. We've defined a function to interact with the API, handled responses, extracted generated text, monitored token usage, and processed multiple requests. We've also discussed error handling, rate limiting, and best practices for working with the API. By following these steps, you can effectively use OpenAI's GPT-3 API to generate text in R for various applications. For the curious, yes, these prompts and responses are generated using the OpenAI API every time you render this notebook.
